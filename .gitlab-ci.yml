stages:
  - build
  - release
  - frontend_build
  - frontend_deploy
  - deploy-to-vm

build-job:
  stage: build
  image: docker:27.1.2
  services:
    - name: docker:27.1.2-dind
      command: ["--tls=false"]
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_DRIVER: overlay2
    DOCKER_BUILDKIT: "1"
    DOCKER_TLS_CERTDIR: ""   # важно для dind без TLS
  before_script:
    # логин в YCR БЕЗ yc, через json_key
    - echo "$SA_PROD_DEPLOYER_PRIVATE_KEY" | docker login --username json_key --password-stdin cr.yandex
    - docker buildx create --use
  script:
    - |
      docker buildx build \
        -f backend/Dockerfile \
        -t "${CI_REGISTRY}/${CI_PROJECT_PATH}:${CI_COMMIT_SHORT_SHA}" \
        --push backend

release-job:
  stage: release
  image: alpine:3.15
  script:
    - apk add -q --no-cache bash curl jq gettext
    - curl --fail --silent --location --remote-name https://storage.yandexcloud.net/yandexcloud-yc/install.sh
    - bash install.sh -i /usr/local/yandex-cloud -n
    - ln -s /usr/local/yandex-cloud/bin/yc /usr/local/bin/yc
    - echo "$SA_PROD_DEPLOYER_PRIVATE_KEY" > key.json
    - yc config profile create sa-profile
    - yc config set service-account-key key.json
    - yc serverless container revision deploy
      --container-id ${CI_CONTAINER_ID_prod}
      --image "${CI_REGISTRY}/${CI_PROJECT_PATH}:${CI_COMMIT_SHORT_SHA}"
      --cores 4
      --memory 1024mb
      --concurrency 1
      --execution-timeout 10s
      --cloud-id ${cloud_id}
      --folder-id ${cart_prod}
      --service-account-id ${PROD_SA_ID}
      --network-id enps2mqrhf2muo7s7d74
      --min-instances 1
      --environment BASE_URL=https://bbapo5ibqs4eg6dail89.containers.yandexcloud.net
      --secret environment-variable=DB_NAME,id=e6qmac6cr2goqb03sfjn,version-id=e6qtom5dst8bamfc4pfh,key=DB_NAME
      --secret environment-variable=DB_HOST,id=e6qmac6cr2goqb03sfjn,version-id=e6qtom5dst8bamfc4pfh,key=DB_HOST
      --secret environment-variable=DB_PASSWORD,id=e6qmac6cr2goqb03sfjn,version-id=e6qtom5dst8bamfc4pfh,key=DB_PASSWORD
      --secret environment-variable=DB_USER,id=e6qmac6cr2goqb03sfjn,version-id=e6qtom5dst8bamfc4pfh,key=DB_USER
      --secret environment-variable=DJANGO_SECRET_KEY,id=e6q6ecgut30u34e250gm,version-id=e6qvonsc1vrqc4noahcg,key=DJANGO_SECRET_KEY
      --secret environment-variable=VK_APP_ID,id=e6q6ecgut30u34e250gm,version-id=e6qvonsc1vrqc4noahcg,key=VK_APP_ID
      --secret environment-variable=VK_APP_SECRET,id=e6q6ecgut30u34e250gm,version-id=e6qvonsc1vrqc4noahcg,key=VK_APP_SECRET
      --secret environment-variable=VK_REDIRECT_URI,id=e6q6ecgut30u34e250gm,version-id=e6qvonsc1vrqc4noahcg,key=VK_REDIRECT_URI 
    - container_id=${prod_container_id}
# Создание продакшн среды.
  environment:
    name: production/$CI_COMMIT_SHORT_SHA

variables:
  # IMAGE определяется в build-job и используется ниже
  DEPLOY_DIR: /srv/eventum
  DEPLOY_USER: deploy
  DEPLOY_HOST: 84.201.185.243

deploy-to-vm:
  stage: release
  image: alpine:3.18
  before_script:
    - apk add --no-cache openssh-client bash curl jq gettext
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - ssh-keyscan -H "$DEPLOY_HOST" >> ~/.ssh/known_hosts
  script:
    # 1) Собираем .env локально (переменные — GitLab CI Protected & Masked)
    - |
      cat > .env <<'EOF'
      DJANGO_SECRET_KEY=${DJANGO_SECRET_KEY}
      DB_NAME=${DB_NAME}
      DB_USER=${DB_USER}
      DB_PASSWORD=${DB_PASSWORD}
      DB_HOST=${DB_HOST}
      BASE_URL=${BASE_URL}
      PORT=8000
      VK_APP_ID=${VK_APP_ID}
      VK_APP_SECRET=${VK_APP_SECRET}
      VK_REDIRECT_URI=${VK_REDIRECT_URI}
      EOF
    - chmod 600 .env

    # 2) Передаём файл .env на VM (scp); если docker-compose.yml меняется — тоже передай
    - scp -o StrictHostKeyChecking=yes .env ${DEPLOY_USER}@${DEPLOY_HOST}:${DEPLOY_DIR}/.env
    # необязательно: scp docker-compose.yml ${DEPLOY_USER}@${DEPLOY_HOST}:${DEPLOY_DIR}/docker-compose.yml

    # 3) На VM: pull образ, обновить и поднять сервисы, миграции, collectstatic
    - |
      ssh ${DEPLOY_USER}@${DEPLOY_HOST} bash -lc "
        set -euo pipefail
        cd ${DEPLOY_DIR}
        export IMAGE='${CI_REGISTRY}/${CI_PROJECT_PATH}:${CI_COMMIT_SHORT_SHA}'

        # тк docker compose v2, используем 'docker compose'
        docker pull \"\$IMAGE\" || true

        # Обновим docker compose (если в compose используется IMAGE переменная, docker compose заменит)
        # Если docker-compose.yml живёт в репо и уже на хосте — можно просто docker compose pull && up
        docker compose pull || true
        docker compose up -d --remove-orphans

        # One-off миграции (без логов в CI)
        docker compose run --rm web python manage.py migrate --noinput

        # collectstatic: можно вынести в CI, но здесь быстрое решение
        docker compose run --rm web python manage.py collectstatic --noinput || true

        # Проверка health
        sleep 2
        docker compose ps
        curl -f --retry 5 --retry-delay 2 --max-time 10 \"https://api.merup.ru/healthz\"
      "
  environment:
    name: production
    url: https://api.merup.ru
  only:
    - master
  when: manual

# ---- FRONTEND BUILD ----

frontend-build:
  stage: frontend_build
  image: node:22-alpine
  script:
    - npm ci --prefix frontend
    - npm run build --prefix frontend   # CRA -> frontend/build, Vite -> frontend/dist
    - |
      # нормализуем в ./dist для унификации
      if [ -d "frontend/build" ]; then mv frontend/build dist; else mv frontend/dist dist; fi
  artifacts:
    paths: [dist]
    expire_in: 1 week
  only: [main, tags]

# ---- FRONTEND DEPLOY to Object Storage ----
frontend-deploy:
  stage: frontend_deploy
  image: python:3.12-alpine
  dependencies: [frontend-build]
  before_script:
    - pip install -q awscli
    - export AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID}"
    - export AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY}"
    - export AWS_DEFAULT_REGION="${AWS_DEFAULT_REGION}"
    - export AWS_ENDPOINT_URL="${AWS_ENDPOINT_URL}"
  script:
    # 1) ассеты с хэшами — год, immutable
    - |
      aws --endpoint-url "$AWS_ENDPOINT_URL" s3 sync dist/ "s3://${S3_BUCKET}/" \
        --delete \
        --exclude "index.html" --exclude "*.map" \
        --metadata-directive REPLACE \
        --cache-control "public, max-age=31536000, immutable"
    # 2) sourcemaps (если есть) — короткий кэш
    - |
      if compgen -G "dist/**/*.map" > /dev/null; then
        aws --endpoint-url "$AWS_ENDPOINT_URL" s3 sync dist/ "s3://${S3_BUCKET}/" \
          --exclude "*" --include "*.map" \
          --metadata-directive REPLACE \
          --cache-control "public, max-age=300"
      fi
    # 3) index.html — no-cache
    - |
      aws --endpoint-url "$AWS_ENDPOINT_URL" s3 cp dist/index.html "s3://${S3_BUCKET}/index.html" \
        --metadata-directive REPLACE \
        --cache-control "no-cache, no-store, must-revalidate" \
        --content-type "text/html; charset=utf-8"
  only: [main, tags]