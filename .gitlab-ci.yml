stages:
  - build
  - deploy

build-job:
  stage: build
  image: docker:27.1.2
  services:
    - name: docker:27.1.2-dind
      command: ["--tls=false"]
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_DRIVER: overlay2
    DOCKER_BUILDKIT: "1"
    DOCKER_TLS_CERTDIR: ""   # важно для dind без TLS
  before_script:
    # логин в YCR БЕЗ yc, через json_key
    - echo "$SA_PROD_DEPLOYER_PRIVATE_KEY" | docker login --username json_key --password-stdin cr.yandex
    - docker buildx create --use
  script:
    - |
      docker buildx build \
        -f backend/Dockerfile \
        -t "${CI_REGISTRY}/${CI_PROJECT_PATH}:${CI_COMMIT_SHORT_SHA}" \
        --push backend

variables:
  DEPLOY_DIR: /srv/eventum
  DEPLOY_USER: deploy
  DEPLOY_HOST: 84.201.185.243

deploy-to-vm:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client bash curl jq gettext
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - ssh-keyscan -H "$DEPLOY_HOST" >> ~/.ssh/known_hosts
  script:
    # 1) Создаём .env локально на раннере (используем printf, чтобы точно подставить значения)
    - |
      IMAGE="${CI_REGISTRY}/${CI_PROJECT_PATH}:${CI_COMMIT_SHORT_SHA}"
      printf 'DJANGO_SECRET_KEY=%s\n' "${DJANGO_SECRET_KEY}" > .env
      printf 'DB_NAME=%s\n' "${DB_NAME}" >> .env
      printf 'DB_USER=%s\n' "${DB_USER}" >> .env
      printf 'DB_PASSWORD=%s\n' "${DB_PASSWORD}" >> .env
      printf 'DB_HOST=%s\n' "${DB_HOST}" >> .env
      printf 'BASE_URL=https://api.merup.ru\n' >> .env
      printf 'PORT=8000\n' >> .env
      printf 'VK_APP_ID=%s\n' "${VK_APP_ID}" >> .env
      printf 'VK_APP_SECRET=%s\n' "${VK_APP_SECRET}" >> .env
      printf 'VK_REDIRECT_URI=%s\n' "${VK_REDIRECT_URI}" >> .env
      printf 'IMAGE=%s\n' "${IMAGE}" >> .env
    - chmod 600 .env
    - scp -o StrictHostKeyChecking=yes .env ${DEPLOY_USER}@${DEPLOY_HOST}:${DEPLOY_DIR}/.env
    - scp -o StrictHostKeyChecking=yes ${CI_PROJECT_DIR}/backend/docker-compose.yml ${DEPLOY_USER}@${DEPLOY_HOST}:${DEPLOY_DIR}/docker-compose.yml || echo "No local docker-compose.yml to copy, assuming exists on host"
    - |
      # Диагностика перед копированием ключа
      echo "=== Диагностика перед копированием ключа ==="
      echo "Размер ключа: $(echo "$SA_PROD_DEPLOYER_PRIVATE_KEY" | wc -c) байт"
      
      # Проверяем доступное место на удаленном сервере
      ssh ${DEPLOY_USER}@${DEPLOY_HOST} "df -h /tmp && echo '---' && ls -ld /tmp && echo '---' && touch /tmp/test_write && rm /tmp/test_write && echo 'Запись в /tmp возможна' || echo 'ОШИБКА: запись в /tmp невозможна'"
      
      # Сохраняем ключ в файл для безопасной передачи
      echo "$SA_PROD_DEPLOYER_PRIVATE_KEY" > /tmp/sa_key.json
      chmod 600 /tmp/sa_key.json
      
      # Копируем ключ на удаленный сервер с verbose режимом для отладки
      echo "=== Начинаем копирование ключа ==="
      scp -v -o StrictHostKeyChecking=yes /tmp/sa_key.json ${DEPLOY_USER}@${DEPLOY_HOST}:/tmp/sa_key.json || {
        echo "ОШИБКА при копировании ключа через scp"
        echo "Пробуем альтернативный метод через stdin..."
        # Альтернативный метод: передаем ключ через stdin
        echo "$SA_PROD_DEPLOYER_PRIVATE_KEY" | ssh ${DEPLOY_USER}@${DEPLOY_HOST} "cat > /tmp/sa_key.json && chmod 600 /tmp/sa_key.json && echo 'Ключ успешно записан альтернативным методом'"
      }
      
      # Проверяем, что файл успешно скопирован
      ssh ${DEPLOY_USER}@${DEPLOY_HOST} "test -f /tmp/sa_key.json && echo 'Файл /tmp/sa_key.json существует' && ls -lh /tmp/sa_key.json || echo 'ОШИБКА: файл не найден'"
      
      # Удаляем локальный ключ
      rm /tmp/sa_key.json
      
      ssh ${DEPLOY_USER}@${DEPLOY_HOST} bash -s <<SSH
        set -euo pipefail

        cd ${DEPLOY_DIR} || { echo "ERROR: deploy dir not found: ${DEPLOY_DIR}" >&2; exit 2; }

        echo "Files in deploy dir:" && ls -la

        # Логинимся в registry (читаем ключ из файла)
        cat /tmp/sa_key.json | docker login --username json_key --password-stdin cr.yandex
        
        # Удаляем ключ с удаленного сервера
        rm /tmp/sa_key.json

        docker compose pull || true
        docker compose up -d --remove-orphans

        # docker compose run --rm backend python manage.py migrate --noinput || true
        # docker compose run --rm backend python manage.py collectstatic --noinput || true

        docker compose ps
        sleep 2
        curl -f --retry 5 --retry-delay 2 --max-time 10 "https://api.merup.ru/healthz" || {
          echo "Health check failed" >&2
          docker compose logs --tail=200
          exit 4
        }

        echo "Deploy finished successfully"
      SSH
  environment:
    name: production
    url: https://api.merup.ru

# ---- FRONTEND BUILD ----

frontend-build:
  stage: build
  image: node:22-alpine
  script:
    - npm ci --prefix frontend
    - npm run build --prefix frontend   # CRA -> frontend/build, Vite -> frontend/dist
    - |
      # нормализуем в ./dist для унификации
      if [ -d "frontend/build" ]; then mv frontend/build dist; else mv frontend/dist dist; fi
  artifacts:
    paths: [dist]
    expire_in: 1 week
  only: [main, tags]

# ---- FRONTEND DEPLOY to Object Storage ----
frontend-deploy:
  stage: deploy
  image: python:3.12-alpine
  dependencies: [frontend-build]
  before_script:
    - pip install -q awscli
    - export AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID}"
    - export AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY}"
    - export AWS_DEFAULT_REGION="${AWS_DEFAULT_REGION}"
    - export AWS_ENDPOINT_URL="${AWS_ENDPOINT_URL}"
  script:
    # 1) ассеты с хэшами — год, immutable
    - |
      aws --endpoint-url "$AWS_ENDPOINT_URL" s3 sync dist/ "s3://${S3_BUCKET}/" \
        --delete \
        --exclude "index.html" --exclude "*.map" \
        --metadata-directive REPLACE \
        --cache-control "public, max-age=31536000, immutable"
    # 2) sourcemaps (если есть) — короткий кэш
    - |
      if compgen -G "dist/**/*.map" > /dev/null; then
        aws --endpoint-url "$AWS_ENDPOINT_URL" s3 sync dist/ "s3://${S3_BUCKET}/" \
          --exclude "*" --include "*.map" \
          --metadata-directive REPLACE \
          --cache-control "public, max-age=300"
      fi
    # 3) index.html — no-cache
    - |
      aws --endpoint-url "$AWS_ENDPOINT_URL" s3 cp dist/index.html "s3://${S3_BUCKET}/index.html" \
        --metadata-directive REPLACE \
        --cache-control "no-cache, no-store, must-revalidate" \
        --content-type "text/html; charset=utf-8"
  only: [main, tags]