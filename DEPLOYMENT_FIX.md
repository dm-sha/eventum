# Исправление проблемы с 403 ошибкой в продакшене

## Проблема
После логина пользователь получает 403 Forbidden ошибку при попытке доступа к `/api/auth/eventums/` и перенаправляется обратно на страницу входа.

## Внесенные исправления

### 1. Исправление настроек DEBUG
- Изменили `DEBUG = True` на `DEBUG = os.getenv('DEBUG', 'False').lower() in ('true', '1', 'yes')`
- Теперь DEBUG контролируется переменной окружения

### 2. Исправление CORS заголовков
- Добавили `'Authorization'` (с заглавной буквы) в `CORS_ALLOWED_HEADERS`
- Оставили и `'authorization'` (строчными) для совместимости

### 3. Добавление middleware для отладки
- Создали `AuthDebugMiddleware` для логирования запросов и ошибок аутентификации
- Добавили настройки логирования в `settings.py`

### 4. Улучшение обработки ошибок на фронтенде
- Добавили подробное логирование ошибок API
- Улучшили процесс обновления токенов

### 5. Улучшение логирования в API
- Добавили детальное логирование в `user_eventums` view

## Развертывание

### 1. Обновите переменные окружения в продакшене
Добавьте в `.env` файл продакшена:
```env
DEBUG=False
```

### 2. Перезапустите бэкенд
```bash
# В контейнере Yandex Cloud
docker-compose restart backend
# или
docker restart <container_name>
```

### 3. Проверьте логи
После развертывания проверьте логи для диагностики:
```bash
# Логи приложения
docker logs <container_name>

# Логи аутентификации (если файл создался)
cat auth_debug.log
```

## Диагностика

### Проверка CORS
Убедитесь, что фронтенд отправляет правильные заголовки:
```javascript
// В консоли браузера
fetch('https://bbapo5ibqs4eg6dail89.containers.yandexcloud.net/api/auth/eventums/', {
  headers: {
    'Authorization': 'Bearer YOUR_TOKEN_HERE'
  }
})
```

### Проверка токенов
1. Проверьте, что токены сохраняются в localStorage
2. Проверьте, что токены не истекли
3. Проверьте, что токены передаются в заголовке Authorization

### Проверка пользователя в базе
Убедитесь, что пользователь существует и имеет роли:
```python
# В Django shell
from app.models import UserProfile, UserRole
user = UserProfile.objects.get(vk_id=YOUR_VK_ID)
roles = UserRole.objects.filter(user=user)
print(f"User: {user.name}, Roles: {[r.role for r in roles]}")
```

## Возможные дополнительные проблемы

1. **Проблемы с VK аутентификацией в продакшене** - проверьте настройки VK приложения
2. **Проблемы с базой данных** - убедитесь, что пользователь и роли созданы правильно
3. **Проблемы с сетью** - проверьте, что запросы доходят до бэкенда

## Мониторинг

После развертывания следите за логами:
- Ошибки аутентификации в консоли браузера
- Логи middleware в бэкенде
- Статус коды ответов API
